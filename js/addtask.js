let subtasks = [];
let subtasksdone = [];
let assignedUsers = [];
let prio = 'Urgent';
let taskMode; // 'add' oder 'edit'
let taskToEdit;
let taskProgressState;
let dropdownInput;
let dropdownList;
let dropdownBoxEventListeners = [];

async function initAddTaskPage() {
    await init();
    taskProgressState = 'toDo';
    taskMode = 'add';
    selectAssigneeElements();
}

/**
 * Adds a new task to the user's task list and updates the user data.
 *
 * @function addNewTask
 * @async
 */

async function addNewTask() {
    taskMode = 'add';
    let title = document.getElementById('title').value;
    let description = document.getElementById('description').value;
    let category = document.getElementById('categorySelect').value;
    let assignedto = assignedUsers;
    let duedate = document.getElementById('duedate').value;
    let id = createTaskId();

    let newTask = {
        "title": title,
        "description": description,
        "category": category,
        "assignedto": assignedto,
        "duedate": duedate,
        "prio": prio,
        "subtasks": subtasks,
        "subtasksdone": subtasksdone,
        "status": taskProgressState,
        "id": await id
    }

    user.tasks.push(newTask);
    updateUser();
    showMessage('../assets/img/board.svg', 'Task added to Board!');

    if (window.location.href.indexOf('board') != -1) {
        closeCard('addTaskBox');
        initTasks();
    } else {
        window.location.href = 'board.html';
    }
    resetForm('add');
    subtasks = [];
    // initTasks();
}


/**
 * Asynchronously creates a new task ID based on the length of the user's tasks array.
 *
 * @async
 * @function createTaskId
 * @returns {Promise<number>} A Promise that resolves to the new task ID.
 * @throws {Error} If there is an issue with fetching actual user data.
 */
async function createTaskId() {
    await getActualUserData();
    let newId = user.tasks.length;
    return newId;
}


/**
 * Creates a new subtask for a given list.
 *
 * This function retrieves the subtask input element, validates its value, and adds the subtask
 * to the specified list if it is not empty. If the input is empty, it displays an alert message.
 * After adding the subtask (if valid), it also updates the subtask list.
 *
 * @function createSubtask
 * @param {string} list - The identifier of the list to which the subtask should be added.
 * @throws {Error} Throws an error if the list identifier is not found.
 */

function createSubtask(list) {
    let subtask = document.getElementById(`edit-subtask_${list}`);
    let subtaskdone = 'notdone';
    if (subtask.value.trim() !== '') {
        subtasks.push(subtask.value);
        subtasksdone.push(subtaskdone);
        document.getElementById('alert').innerHTML = '';
        subtask.value = '';
    }
    else {
        document.getElementById('alert').innerHTML = 'Bitte etwas eingeben!';
    }
    actualiseSubtaskList(list);
}


/**
 * Updates the subtask list in the specified HTML element with new subtask items.
 *
 * This function clears the existing content of the specified HTML element and populates
 * it with new subtask items based on the contents of the 'subtasks' array. Each subtask
 * item is wrapped in an HTML list item (<li>) and may include additional HTML elements
 * generated by the 'getSubtaskTemplate' function. The function adds CSS classes for styling.
 *
 * @function actualiseSubtaskList
 * @param {string} list - The identifier of the HTML element where the subtask list should be updated.
 */

function actualiseSubtaskList(list) {
    let subTaskList = document.getElementById(list);
    subTaskList.innerHTML = '';
    subtasks.forEach((subtask, index) => {
        let subtaskElement = document.createElement('li');
        subtaskElement.innerHTML += /*html*/ `<div id="subtask${index}_${list}">${subtask}</div>`;
        subtaskElement.innerHTML += getSubtaskTemplate(index, list);
        subtaskElement.classList.add('d-flex-space-between');
        subTaskList.appendChild(subtaskElement);
    });
}


/**
 * Removes a subtask from the 'subtasks' array and updates the subtask list in the specified HTML element.
 *
 * This function removes a subtask and its corresponding completion status from the 'subtasks' and 'subtasksdone'
 * arrays based on the provided index. After removal, it updates the subtask list displayed in the specified HTML
 * element using the 'actualiseSubtaskList' function.
 *
 * @function removeSubtask
 * @param {number} index - The index of the subtask to be removed from the 'subtasks' and 'subtasksdone' arrays.
 * @param {string} list - The identifier of the HTML element where the subtask list should be updated.
 * @throws {Error} Throws an error if the provided index is out of bounds or if updating the subtask list fails.
 */

function removeSubtask(index, list) {
    subtasks.splice(index, 1);
    subtasksdone.splice(index, 1);
    actualiseSubtaskList(list);
}


/**
 * Prepares the application to add a new task.
 *
 * This function sets the task progress state to 'toDo' and task mode to 'add' to indicate that
 * a new task is being added. It then displays the task entry interface by showing the 'addTaskBox'
 * element. Additionally, it clears the content of the 'addSubtasksList' HTML element.
 *
 * @function addTask
 */

function addTask() {
    taskProgressState = 'toDo';
    taskMode = 'add';
    selectAssigneeElements();
    showTask('addTaskBox');

    document.getElementById('addSubtasksList').innerHTML = '';
}


/**
 * Prepares the application to add a new task with a specified progress state.
 *
 * This function sets the task progress state to the provided 'state' value and task mode to 'add'
 * to indicate that a new task is being added. It then displays the task entry interface by showing
 * the 'addTaskBox' element.
 *
 * @function addTaskSmallBtn
 * @param {string} state - The progress state of the new task (e.g., 'toDo', 'inProgress', 'completed').
 */

function addTaskSmallBtn(state) {
    taskProgressState = state;
    taskMode = 'add';
    showTask('addTaskBox');
}


/**
 * Prepares the application to edit an existing task with the specified task ID.
 *
 * This function sets the task mode to 'edit' to indicate that an existing task is being edited.
 * It retrieves the task details for the specified task ID from the 'user.tasks' array and populates
 * the corresponding input fields in the task editing interface. It also manages subtasks, hides/shows
 * relevant UI elements, and updates the subtask list.
 *
 * @function editTask
 * @param {number} taskId - The unique identifier of the task to be edited.
 * @throws {Error} Throws an error if the provided task ID is invalid or if any UI updates fail.
 */

function editTask(taskId) {
    taskMode = 'edit';
    taskToEdit = user.tasks[taskId];
    assignedUsers = taskToEdit.assignedto;
    selectAssigneeElements();

    document.getElementById('edit-title').value = taskToEdit.title;
    document.getElementById('edit-description').value = taskToEdit.description;
    document.getElementById('edit-category').value = taskToEdit.category;
    document.getElementById('edit-duedate').value = taskToEdit.duedate;
    document.getElementById('edit-progress-state').value = taskToEdit.status;
    setPrio(taskToEdit.prio, 'edit');
    document.getElementById('editSubtasksList').innerHTML = actualiseSubtaskList('editSubtasksList');
    listEditSubtasks(taskId);
    subtasks = user.tasks[taskId].subtasks;

    showContent('hide', 'cardTaskDetails', 'd-none');
    showContent('show', 'editTaskBox', 'd-none');
    showContent('show', 'cardBgr', 'd-none');
}


/**
 * Saves the edited task with updated information.
 *
 * @function saveEditedTask
 */

function saveEditedTask() {
    let title = document.getElementById('edit-title').value;
    let description = document.getElementById('edit-description').value;
    let assignedto = assignedUsers;
    let duedate = document.getElementById('edit-duedate').value;
    let newPrio = prio;
    let category = document.getElementById('edit-category').value;
    let progressState = document.getElementById('edit-progress-state').value;

    taskToEdit.title = title;
    taskToEdit.description = description;
    taskToEdit.assignedto = assignedto;
    taskToEdit.duedate = duedate;
    taskToEdit.prio = newPrio;
    taskToEdit.category = category;
    taskToEdit.status = progressState;

    updateUser();
    initTasks();
    closeCard('editTaskBox');
    showMessage('./assets/img/check.svg', 'Task successfully updated!');
}


/**
 * Deletes a task with the specified task ID and performs related actions.
 *
 * This function removes the task from the 'user.tasks' array based on the provided task ID.
 * It then updates the user's data using the 'updateUser' function, closes the task details card
 * if open, initializes the tasks list, and displays a success message to the user.
 *
 * @function deleteTask
 * @param {number} taskId - The unique identifier of the task to be deleted.
 * @throws {Error} Throws an error if the provided task ID is invalid or if any action fails.
 */

function deleteTask(taskId) {
    user.tasks.splice(taskId, 1);
    updateUser();
    closeCard('cardTaskDetails');
    initTasks();
    showMessage('./assets/img/delete_white.svg', 'Task successfully deleted!');
}


/**
 * Populates the options of select fields in the task editing interface based on user task data.
 *
 * This function iterates through an array of select field IDs, retrieves the actual values
 * to load for each field using the 'getActualSelectField' function, and sets the options in
 * the corresponding select field using the 'setOptionsInSelect' function.
 *
 * @function selectEditTaskOptions
 * @param {object} userTask - The user task data containing information to populate select fields.
 * @throws {Error} Throws an error if any of the select field operations fail.
 */

function selectEditTaskOptions(userTask) {
    for (let i = 0; i < selectFieldIds.length; i++) {
        const actualSelectField = selectFieldIds[i];
        let actualValueToLoad = getActualSelectField(actualSelectField, userTask);

        setOptionsInSelect(actualValueToLoad, actualSelectField);
    }
}


/**
 * Selects the appropriate subtask list element based on the current task mode.
 *
 * This function determines the task editing mode ('edit' or 'add') and selects the corresponding
 * subtask list element by its HTML ID ('editSubtasksList' or 'addSubtasksList'). It returns the
 * selected subtask list element for further manipulation.
 *
 * @function selectSubtaskList
 * @returns {HTMLElement} The HTML element representing the selected subtask list.
 */

function selectSubtaskList() {
    let selectCorrectSubtaskList;
    if (taskMode == 'edit') {
        selectCorrectSubtaskList = document.getElementById('editSubtasksList');
    } else if (taskMode == 'add') {
        selectCorrectSubtaskList = document.getElementById('addSubtasksList');
    }
    return selectCorrectSubtaskList;
}


/**
 * Retrieves the actual value to load into a select field based on the select field identifier and user task data.
 *
 * This function takes an `actualSelectField` identifier and the `userTask` object containing task data.
 * It determines which field from the user task data to retrieve based on the identifier and returns the
 * actual value to load into the corresponding select field.
 *
 * @function getActualSelectField
 * @param {string} actualSelectField - The identifier of the select field to retrieve data for (e.g., 'edit-category', 'edit-assignedto').
 * @param {object} userTask - The user task data containing information to populate select fields.
 * @returns {string} The actual value to load into the specified select field.
 */

function getActualSelectField(actualSelectField, userTask) {
    if (actualSelectField == 'edit-category') {
        actualValueToLoad = userTask.category;
    } else if (actualSelectField == 'edit-assignedto') {
        actualValueToLoad = userTask.assignedto;
    }
    return actualValueToLoad;
}


/**
 * Sets the selected option in a select field based on the actual value to load.
 *
 * This function takes the `actualValueToLoad` and the `actualSelectField` identifier to determine
 * which option in the select field should be selected. It iterates through the options of the select
 * field, sets the 'selected' attribute to 'true' for the matching option, and sets it to 'false' for
 * all other options.
 *
 * @function setOptionsInSelect
 * @param {string} actualValueToLoad - The actual value to load into the select field.
 * @param {string} actualSelectField - The identifier of the select field to set options in.
 */

function setOptionsInSelect(actualValueToLoad, actualSelectField) {
    let actualSelectFieldDocument = document.getElementById(actualSelectField);

    for (let j = 0; j < actualSelectFieldDocument.options.length; j++) {
        const actualOption = actualSelectFieldDocument.options[j];

        if (actualOption.value == actualValueToLoad) {
            document.getElementById(actualSelectField).setAttribute("selected", "true");
            break;
        } else {
            document.getElementById(actualSelectField).setAttribute("selected", "false");
        }
    }
}


/**
 * Prepares a subtask for editing within a specified list.
 *
 * This function retrieves the necessary HTML elements related to a subtask at a given index
 * within the specified list. It hides the subtask text and edit icons, displays the input field
 * for editing, and populates the input field with the current subtask content.
 *
 * @function editSubtask
 * @param {number} index - The index of the subtask to be edited.
 * @param {string} list - The identifier of the list containing the subtask to be edited.
 */

function editSubtask(index, list) {
    let subtask = document.getElementById(`subtask${index}_${list}`);
    let editIcons = document.getElementById(`editIcons${index}_${list}`);
    let inputDiv = document.getElementById(`editSubtaskInputDiv_${index}_${list}`);
    let input = document.getElementById(`editSubtaskInput_${index}_${list}`);
    subtask.classList.add('d-none');
    editIcons.classList.add('d-none');
    inputDiv.classList.remove('d-none');
    input.value = subtasks[index];
}


/**
 * Confirms the editing of a subtask and updates the subtask list in the specified list.
 *
 * This function retrieves the edited subtask content from the input field, updates the 'subtasks'
 * array at the specified index, and then updates the subtask list within the specified list container.
 * Finally, it hides the editing input field.
 *
 * @function confirmEditSubtask
 * @param {number} index - The index of the subtask being edited.
 * @param {string} list - The identifier of the list containing the subtask.
 */

function confirmEditSubtask(index, list) {
    let editedSubtask = document.getElementById(`editSubtaskInput_${index}_${list}`);
    subtasks[index] = editedSubtask.value;
    actualiseSubtaskList(list);
    editedSubtask.classList.add('d-none');
}


/**
 * Resets the form fields of either the "Add Task" or "Edit Task" form.
 *
 * This function accepts an `addOrEdit` parameter to determine which form to reset.
 * If 'add' is provided, it resets the "Add Task" form; if 'edit' is provided, it resets
 * the "Edit Task" form by calling the `reset()` method on the respective form element.
 *
 * @function resetForm
 * @param {string} addOrEdit - A string specifying whether to reset the "Add Task" or "Edit Task" form ('add' or 'edit').
 */

function resetForm(addOrEdit) {
    if (addOrEdit == 'add') {
        document.getElementById('addTaskForm').reset();
    } else if (addOrEdit == 'edit') {
        document.getElementById('editTaskForm').reset();
    }
}

function addNewAssignee(contactId) {
    let assigneeInput;
    if (taskMode == 'add') {
        assigneeInput = document.getElementById('addtask-assign-new-user');
    } else {
        assigneeInput = document.getElementById('edittask-assign-new-user');
    }

    if (assignedUsers.indexOf(contactId) == -1) {
        assignedUsers.push(contactId);
    }
    listAssignedUsersBox();
    assigneeInput.value = '';
}

function listAssignedUsersBox() {
    let assignedUsersBox;
    if (taskMode == 'add') {
        assignedUsersBox = document.getElementById('addtask-assigned-users-box');
    } else {
        assignedUsersBox = document.getElementById('edittask-assigned-users-box');
    }

    if (assignedUsers.length === 0) {
        assignedUsersBox.innerHTML = `
            <div class="assigned-users-placeholder">
                No assigned users yet
            </div>
        `;
    } else {
        generateAssignedUserList(assignedUsersBox);
    }
}

function generateAssignedUserList(assignedUsersBox) {
    assignedUsersBox.innerHTML = '';
    for (let i = 0; i < assignedUsers.length; i++) {
        const assignedUserId = assignedUsers[i];
        const foundContact = user.contacts.find(contact => contact.id === assignedUserId);
        if (foundContact) {
            assignedUsersBox.innerHTML += assigneeListHTMLTemplate(foundContact.name, i);
        } else if (assignedUserId === actualUser) {
            assignedUsersBox.innerHTML += assigneeListHTMLTemplate('You', i);
        }
    }
}

function deleteAssignee(i) {
    assignedUsers.splice(i, 1);
    listAssignedUsersBox();
}

function showAssigneeList() {
    let contacts = user.contacts;
    let contactsDropDown;
    if (taskMode == 'add') {
        contactsDropDown = document.getElementById('addtask-assigned-dropdown-list');
    } else {
        contactsDropDown = document.getElementById('edittask-assigned-dropdown-list');
    }

    contactsDropDown.innerHTML = '';
    contactsDropDown.innerHTML += `<li onclick="addNewAssignee('${user.id}')">${user.name}</li>`;

    for (let i = 0; i < contacts.length; i++) {
        const contactName = contacts[i].name;
        const contactId = contacts[i].id;
        contactsDropDown.innerHTML +=
            `<li onclick="addNewAssignee(${contactId})">${contactName}</li>`;
    }
}

function selectDropdownBoxElement() {
    if (taskMode == 'add') {
        dropdownInput = document.getElementById('addtask-assign-new-user');
        dropdownList = document.getElementById('addtask-assigned-dropdown-list');
    } else if (taskMode == 'edit') {
        dropdownInput = document.getElementById('edittask-assign-new-user');
        dropdownList = document.getElementById('edittask-assigned-dropdown-list');
    }
}

function selectAssigneeElements() {
    showAssigneeList();
    listAssignedUsersBox();
    selectDropdownBox();
}


/* ==========================================================================
   Priority Button functions
   ========================================================================== */

/**
 * Sets the priority level and updates the corresponding user interface elements.
 *
 * This function sets the `prio` variable to the provided `selectedPrio` value and updates
 * the user interface by selecting the correct priority button based on the `selectedPrio`.
 * It also determines the set of priority button IDs to select from using the `selectPrioIdSet`
 * function.
 *
 * @function setPrio
 * @param {string} selectedPrio - The priority level to be set.
 * @param {string} addOrEdit - A string specifying whether the priority is being set in an "Add" or "Edit" context.
 */

function setPrio(selectedPrio, addOrEdit) {
    prio = selectedPrio;
    let acutalPrioIds = selectPrioIdSet(addOrEdit);
    selectCorrectBtn(selectedPrio, acutalPrioIds);
}


/**
 * Selects the set of priority button and image IDs based on the context (add or edit).
 *
 * This function determines the set of priority button and image IDs to work with based on
 * the provided `addOrEdit` parameter. In an "Edit" context, it returns the IDs for editing
 * priority buttons and images; in an "Add" context, it returns the IDs for adding priority
 * buttons and images.
 *
 * @function selectPrioIdSet
 * @param {string} addOrEdit - A string specifying whether the function is used in an "Add" or "Edit" context.
 * @returns {Array<string>} An array of priority button and image IDs to work with based on the context.
 */

function selectPrioIdSet(addOrEdit) {
    let actualPrioIds = [];

    if (addOrEdit == 'edit') {
        actualPrioIds = ['edit-btnUrgent', 'edit-imgPrioUrgent', 'edit-btnMedium', 'edit-imgPrioMedium', 'edit-btnLow', 'edit-imgPrioLow'];
    } else if (addOrEdit == 'add') {
        actualPrioIds = ['btnUrgent', 'imgPrioUrgent', 'btnMedium', 'imgPrioMedium', 'btnLow', 'imgPrioLow'];
    }

    return actualPrioIds;
}


/**
 * Selects the correct button based on the selected priority and updates
 * the priority using the provided actual priority IDs.
 *
 * @param {string} selectedPrio - The selected priority, which can be one of 'Urgent', 'Medium', or 'Low'.
 * @param {Array<string>} acutalPrioIds - An array of actual priority IDs to be updated.
 * @returns {void}
 */

function selectCorrectBtn(selectedPrio, acutalPrioIds) {
    if (selectedPrio == 'Urgent') {
        updatePriority(acutalPrioIds, 'urgent');;
    }
    if (selectedPrio == 'Medium') {
        updatePriority(acutalPrioIds, 'medium');;
    }
    if (selectedPrio == 'Low') {
        updatePriority(acutalPrioIds, 'low');;
    }
}


/**
 * Updates the priority display based on the specified priority value.
 *
 * @param {string[]} acutalPrioIds - An array of HTML element IDs associated with priority display elements.
 * @param {string} priority - The priority value to set, which can be 'urgent', 'medium', or 'low'.
 * @returns {void}
 */

function updatePriority(acutalPrioIds, priority) {
    if (priority === 'urgent') {
        showContent('hide', acutalPrioIds[0], 'addtask-priority-urgent');
        document.getElementById(acutalPrioIds[1]).src = './assets/img/addtask_urgent_white.svg';
        showContent('show', acutalPrioIds[2], 'addtask-priority-medium');
        document.getElementById(acutalPrioIds[3]).src = './assets/img/addtask_medium.svg';
        showContent('show', acutalPrioIds[4], 'addtask-priority-low');
        document.getElementById(acutalPrioIds[5]).src = './assets/img/addtask_low.svg';
    } else if (priority === 'medium') {
        showContent('show', acutalPrioIds[0], 'addtask-priority-urgent');
        document.getElementById(acutalPrioIds[1]).src = './assets/img/addtask_urgent.svg';
        showContent('hide', acutalPrioIds[2], 'addtask-priority-medium');
        document.getElementById(acutalPrioIds[3]).src = './assets/img/addtask_medium_white.svg';
        showContent('show', acutalPrioIds[4], 'addtask-priority-low');
        document.getElementById(acutalPrioIds[5]).src = './assets/img/addtask_low.svg';
    } else if (priority === 'low') {
        showContent('show', acutalPrioIds[0], 'addtask-priority-urgent');
        document.getElementById(acutalPrioIds[1]).src = './assets/img/addtask_urgent.svg';
        showContent('show', acutalPrioIds[2], 'addtask-priority-medium');
        document.getElementById(acutalPrioIds[3]).src = './assets/img/addtask_medium.svg';
        showContent('hide', acutalPrioIds[4], 'addtask-priority-low');
        document.getElementById(acutalPrioIds[5]).src = './assets/img/addtask_low_white.svg';
    }
}


/**
 * Sets the minimum date for an HTML input element with the ID 'duedate' to the current date.
 * Clears an interval (if defined) after setting the minimum date.
 *
 * @returns {void}
 */

function setMinDate() {
    const element = document.getElementById('duedate');

    if (element) {
        const today = new Date();
        const year = today.getFullYear();
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');

        const currentDate = `${year}-${month}-${day}`;
        element.min = currentDate;

        clearInterval(intervalID);  // Stop the interval once the element is found and min is set
    }
}

const intervalID = setInterval(setMinDate, 100);

/* ==========================================================================
   Everything eventListener related
   ========================================================================== */

function selectDropdownBox() {
    selectDropdownBoxElement();

    let dropdownVisible = dropdownInput.addEventListener('click', function () {
        // Toggle the visibility of the dropdown list
        if (dropdownList.style.display === 'none' || dropdownList.style.display === '') {
            dropdownList.style.display = 'block';
        } else {
            dropdownList.style.display = 'none';
        }
    });

    // Close the dropdown if the user clicks outside of it
    let dropdownInvisible = document.addEventListener('click', function (event) {
        if (!dropdownInput.contains(event.target) && !dropdownList.contains(event.target)) {
            dropdownList.style.display = 'none';
        }
    });

    // Handle selection of dropdown items
    let selectDropdownItem = dropdownList.addEventListener('click', function (event) {
        if (event.target.tagName === 'LI') {
            // dropdownInput.value = event.target.textContent;
            dropdownList.style.display = 'none';
        }
    });

    dropdownBoxEventListeners.push(dropdownVisible);
    dropdownBoxEventListeners.push(dropdownInvisible);
    dropdownBoxEventListeners.push(selectDropdownItem);
}

function removeEventListeners() {
    for (let i = 0; i < dropdownBoxEventListeners.length; i++) {
        const { target, type, listener } = dropdownBoxEventListeners[i];
        target.removeEventListener(type, listener);
    }
}    